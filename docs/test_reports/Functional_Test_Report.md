# Segar test report

## 1. Test environment

| project | content |
|------|------|
| hardware | x86_64 / orin |
| operating system | ubuntu22.04 |
| beta version | Segar 2.0.0 |
| Test date | 2026/2/11 |

## 2. Test conclusion

**pass**

## 3. Test cases

| Use case number | Use case introduction | Test process | pass conditions | Test results |
|----------|----------|----------|----------|----------|
| SegarTestCase001 | Action sends Goal synchronously and waits for the result | 1. Create Action Server nodes and Action Client nodes, and verify that the nodes are created successfully. <br>2. Register DemoAction on the Server node, configure on_goal/on_cancel/on_execute: on_execute is executed in a loop according to goal.exec_times(), Feedback is sent each time, and finally Succeed returns result (including total and full_sequence). <br>3. Create an Action Client with the same name on the Client node, construct Goal (exec_times=5) after WaitForService, call synchronous SendGoal and wait for return. <br>4. Verify that the returned Goal status is SUCCEEDED; verify that result.total() and result.detail().full_sequence().size() are equal to exec_times; verify that the Feedback callback is called no less than exec_times. | 1. The Server/Client node is created successfully, and the Action Server/Client is created successfully. <br>2. Client can successfully send Goal and get a synchronous return. <br>3. The result status is SUCCEEDED. <br>4. The length of result.total() and full_sequence is consistent with exec_times. <br>5. The number of Feedback received ≥ exec_times. | PASS |
| SegarTestCase002 | Action sends Goal asynchronously and waits for the result | 1. Same as 001, create Server/Client node and DemoAction Server (on_execute sends Feedback and then Succeed). <br>2. Client uses AsyncSendGoal to send Goal, receives the result through on_result callback, and counts the number of feedback through on_feedback; the main process waits in the loop for the result_received flag or times out for 5 seconds. <br>3. Record received_status and received_result in on_result; the main process verifies that result_received is true, received_status is SUCCEEDED, and received_result.total() and full_sequence are correct. <br>4. Verify feedback_count ≥ exec_times. | 1. Server/Client and Action Server/Client are created successfully. <br>2. AsyncSendGoal is called successfully and on_result is called. <br>3. received_status is SUCCEEDED; total and full_sequence of received_result are consistent with goal. <br>4. Feedback times ≥ exec_times. | PASS |
| SegarTestCase003 | Action Cancel Goal in synchronization scenario | 1. Create a Server/Client node; in Server's on_execute, check cancel_requested in the loop. If it is true, construct a partial result and call CancelGoal(goal_id, result) to return. <br>2. After the Client synchronizes SendGoal, it calls CancelGoal in another thread or after timing, and then waits for the synchronized SendGoal to return. <br>3. Verify that the return status is the cancellation-related status (such as CANCELED); verify that the total and sequence in the result are partial results before cancellation. | 1. Server can accept Goal and respond to cancellation during execution. <br>2. The Client receives the cancellation result after calling CancelGoal. <br>3. The result status indicates that it has been cancelled; part of the result (total, sequence) is consistent with the execution progress. | PASS |
| SegarTestCase004 | Action Cancel Goal in asynchronous scenario | 1. Similar to 003, Server responds to cancel_requested and CancelGoal in on_execute. <br>2. Client uses AsyncSendGoal to call CancelGoal at the appropriate time; record status and result in the on_result callback. <br>3. Verify that on_result is called, status is the cancellation status, and result is the partial result. | 1. The asynchronous SendGoal and CancelGoal calls are successful. <br>2. on_result is called and status indicates canceled. <br>3. The total/sequence in result is the partial result when cancelled. | PASS |
| SegarTestCase005 | ROS2 recording and playback | 1. Start the ROS2 demo talker process and publish to rt/chatter (String type). <br>2. Call the segar record command, specify the output record file, and stop recording after a period of time. <br>3. Read the record file, parse the header (version, message_number, Topic_number, etc.) and index area to get Topic_info. <br>4. Call the segar play command to play back the record file. <br>5. Subscribe to the corresponding Topic on the playback side, count the number and content of messages received, and compare it with the expectation on the recording side (or the message_number/Topic information in the record). | 1. The record file can be generated successfully and can be parsed. <br>2. The Topic_number, message_number, and Topic_info parsed from the header and index are reasonable. <br>3. Playback can start normally and publish messages. <br>4. The number and content of messages received during playback are consistent with the recording (or consistent with the record metadata). | PASS |
| SegarTestCase006 | Segar IDL message recording and playback | 1. Create a Segar node and a Writer to publish HelloWorld (IDL) messages to the specified Topic and publish them in a fixed number of cycles. <br>2. Start segar record, record the Topic, and get the record file after the recording is completed. <br>3. Execute segar bag info on the record file and parse the output duration, message_number, Topic_number, Topic_info (Topic name, message number, type). <br>4. Start segar play to play back the record; create a Reader to subscribe to the same Topic and receive playback messages. <br>5. Verify that the number of messages, duration, and Topic type parsed by bag info are consistent with expectations; verify that the number and content of messages received during playback are consistent with those sent during recording. | 1. The recording file is generated and can be correctly parsed by bag info. <br>2. message_number, Topic_number, Topic_info (including type) in bag info are correct. <br>3. The number of messages received after playback is equal to the number of recorded messages. <br>4. Playback of the received HelloWorld content is consistent with recording and sending. | PASS |
| SegarTestCase007 | Segar Proto message recording and playback | 1. Create a Segar node, use Proto type (such as Chatter) to publish messages to the specified Topic, and send multiple messages in a loop. <br>2. Use segar record to record; use segar bag info to parse the record. <br>3. Use segar play to play back; create a Reader to receive playback messages. <br>4. Verify the number of messages and Topic type in the record; verify that the number and content (such as seq, content, timestamp) received in the playback are consistent with those sent. | 1. Proto message recording and bag info parsing are correct. <br>2. The number of playback messages is consistent with that of recording. <br>3. Each field of the playback message (such as seq, content, timestamp) is consistent with that of sending. | PASS |
| SegarTestCase008 | CLI Help and Versions | 1. Execute segar -h and segar --help, and check that the standard output contains help information such as usage and subcommand list. <br>2. Execute segar --version and check that the output contains version number information. <br>3. Execute the segar unknown subcommand (such as segar unknown_cmd) and check the standard error or standard output for error prompts or usage prompts. | 1. -h/--help output includes usage and command description. <br>2. --version The output contains the version number. <br>3. Unknown subcommands can give clear error or help prompts. | PASS |
| SegarTestCase009 | CLI node list and information | 1. Create a node with the specified name using CreateNode in the process and keep the node alive (such as holding the node or running it for a period of time). <br>2. Execute segar node list, parse the output, and check that the list contains the name of the newly created node. <br>3. Execute segar node info `<node_name>` and check that the output contains the node name and node-related information (such as Topic, service, etc.). | 1. The node list output contains the names of the nodes created. <br>2. node info `<node_name>` can output the node information and the content is reasonable. | PASS |
| SegarTestCase010 | CLI Topic (IDL) related commands | 1. Create a Segar node and a Writer to publish IDL type (HelloWorld) messages to a certain Topic (such as cli_test_Topic). The background thread continues to publish at a fixed interval (such as 50ms) to keep the node and publication alive. <br>2. After waiting for about 500ms, execute in parallel: segar Topic list, Topic type `<topic>`, Topic info `<topic>`, Topic hz `<topic>` (timeout 5s), Topic bw `<topic>` (timeout 5s), Topic echo `<topic>` (timeout 5s). <br>3. Verify that the list output contains the Topic; the type output is the IDL type name; the info output contains the type and writer/reader information. <br>4. Verify that the exit code of hz, bw, and echo commands is 0 (normal) or 124 (timeout), and the standard output is not empty. <br>5. Stop the publishing thread. | 1. Topic list contains this Topic. <br>2. Topic type outputs the correct IDL type name. <br>3. The output type of Topic info is the same as the writer/reader information and is consistent with the actual situation. <br>4. The exit code of Topic hz is 0 or 124, and the output is not empty. <br>5. The exit code of Topic bw is 0 or 124, and the output is not empty. <br>6. The exit code of Topic echo is 0 or 124, and the output is not empty. | PASS |
| SegarTestCase011 | CLI Topic (Proto) related commands | 1. Create a Segar node and a Writer to publish Proto type (Chatter) messages to a certain Topic (such as cli_test_proto_Topic). The background thread continues to publish at a fixed interval (such as 50ms). <br>2. After waiting for about 500ms, execute in parallel: segar Topic list, Topic type `<topic>`, Topic info `<topic>`, Topic hz `<topic>` (timeout 5s), Topic bw `<topic>` (timeout 5s), Topic echo `<topic>` (timeout 5s). <br>3. Verify that the list contains the Topic; type output is a Proto type path (such as rti.segar.examples.proto.Chatter); info is consistent with the Topic type and participants. <br>4. Verify that the exit code of hz, bw, and echo commands is 0 or 124, and the standard output is not empty. <br>5. Stop the publishing thread. | 1. Topic list contains this Topic. <br>2. Topic type outputs the correct Proto type path. <br>3. Topic info is consistent with the current Topic type and participants. <br>4. The exit code of Topic hz is 0 or 124, and the output is not empty. <br>5. The exit code of Topic bw is 0 or 124, and the output is not empty. <br>6. The exit code of Topic echo is 0 or 124, and the output is not empty. | PASS |
| SegarTestCase012 | CLI Service related commands | 1. Create a Segar node, create an AddTwoInts server and register it with the specified service name. <br>2. Execute segar service list and check that the output contains the service name. <br>3. Execute segar service type `<service_name>` and check that the output is the corresponding type of AddTwoInts. <br>4. Execute segar service info `<service_name>` and check that the output contains type and server information. | 1. The service list contains the service. <br>2. service type outputs the correct srv type. <br>3. The service info output type and server information are correct. | PASS |
| SegarTestCase013 | CLI Action related commands | 1. Create a Segar node, create the Action Server of DemoAction and register it to the specified Action name. <br>2. Execute segar Action list and check that the Action name is included. <br>3. Execute segar Action type `<action_name>` and check that the output is of DemoAction type. <br>4. Execute segar Action info `<action_name>` and check that the output contains type and server information. | 1. The Action list contains the Action. <br>2. Action type outputs the correct Action type. <br>3. The Action info output type and server information are correct. | PASS |
| SegarTestCase014 | CLI parameter related commands | 1. Create a Segar node and set several local parameters (such as int, string) through Segar_Set_Local_Param. <br>2. Execute segar param list (if any) and check the information related to the node or parameter. <br>3. Execute segar param get `<node>` `<param>` (or equivalent command) and check that the output is consistent with the set value. <br>4. Execute segar param set to modify the parameters and get again to check that the modification takes effect. | 1. Param related commands can correctly list/get/set the node parameters. <br>2. The output of get is consistent with the value of set. <br>3. Set and then get again to reflect the latest value. | PASS |
| SegarTestCase015 | Local parameter reading and writing (int/string/proto) | 1. Create a Segar node. <br>2. Use Segar_Set_Local_Param to set the int type parameter, and then read it with Segar_Get_Local_Param. The check values ​​are consistent. <br>3. Set string type parameters, read and verify. <br>4. Set Protobuf type parameters (such as param::Header, including module_name, sequence_num, points, etc.), use Segar_Get_Local_Param to read by value or by shared_ptr, and verify that each field is consistent with the settings. | 1. The get value after int/string parameter set is consistent. <br>2. After Proto parameter set, get (value mode), all fields are consistent. <br>3. All fields of Proto parameter get (shared_ptr method) are consistent. | PASS |
| SegarTestCase016 | Remote Parameters (Parameter Service) | 1. Create a parameter server node and export or set several parameters (such as loading from file or Set_Local_Param). <br>2. Create a client node and get/set remote parameters by parameter name through parameter service API (such as GetParameter/SetParameter). <br>3. Execute get/set on multiple types (such as int, string, proto), and verify that the return value is consistent with the set value. <br>4. When the verification type does not match or there is no parameter, the behavior is as expected (such as returning an error or default value). | 1. The client can successfully get the parameters exported by the server and the values ​​are correct. <br>2. After the client sets, the server or get again can reflect the new value. <br>3. Multi-type parameters are read and written correctly. | PASS |
| SegarTestCase017 | ROS2 Talker → Segar Listener | 1. Start ROS2 demo talker (publish to rt/chatter, String type). <br>2. Create a Segar node, create a Reader to subscribe to rt/chatter, and the message type is String. <br>3. Count the number and content of received messages (such as the data field) in the Reader callback. <br>4. After waiting for a period of time or reaching the expected number of messages, verify that the number of received messages is consistent with the talker sending frequency × time, and the content is consistent with the ROS2 sending. | 1. Segar Reader can receive messages published by ROS2 talker. <br>2. The number of messages received is in line with expectations. <br>3. The message content (such as String.data) is consistent with ROS2 sending. | PASS |
| SegarTestCase018 | Segar Talker → ROS2 Listener | 1. Create a Segar node and a Writer to publish String messages to rt/chatter at a fixed frequency or number. <br>2. Start ROS2 demo listener (subscribe chatter). <br>3. Verify that the number and content (such as data) of messages received by the ROS2 end are consistent with those sent by Segar. | 1. ROS2 listener can receive messages published by Segar. <br>2. The number of messages received is consistent with the number of messages sent by Segar. <br>3. The content of the message is consistent with that sent by Segar. | PASS |
| SegarTestCase019 | Service AddTwoInts synchronous call | 1. Create a server node, register the AddTwoInts service, and the processing logic is response.sum = request.a + request.b. <br>2. Create a client node, create AddTwoInts Client, and call SyncSendRequest(a, b) multiple times after WaitForService. Each time a and b are set according to the test data (such as a=seq, b=seq*2). <br>3. Verify that response is not empty and response.sum() == a + b each time; at the same time, verify the response time of a single request (such as ≤10ms). <br>4. Verify that the number of requests processed by the server is consistent with the number of requests sent by the client. | 1. Each SyncSendRequest returns a non-empty response. <br>2. response.sum() is equal to request.a + request.b. <br>3. The response time is within the agreed threshold (such as ≤10ms). <br>4. The number of server processing times is consistent with the number of client requests. | PASS |
| SegarTestCase020 | Service HelloWorld synchronous call | 1. Create the HelloWorld server and return the incremental index or agreed field in the processing logic. <br>2. Create a client and make multiple SyncSendRequests. Each time, verify that the index, message and other fields in the response are consistent with expectations. <br>3. Verify that all requests are successful and the response content is correct. | 1. Every request gets a non-empty response. <br>2. Each response field (such as index, message) is consistent with the server logic. <br>3. The results of multiple rounds of requests are correct. | PASS |
| SegarTestCase021 | Service AddTwoInts asynchronous call | 1. Create the AddTwoInts server and client; the client uses AsyncSendRequest to send multiple requests, verify response.sum() == request.a + request.b in the callback, and count the number of callbacks. <br>2. The main process waits for all asynchronous callbacks to complete (or timeout). <br>3. Verify that the number of callbacks is equal to the number of requests sent, and each response is correct. | 1. The callback for each asynchronous request is called. <br>2. response.sum() in callback is correct. <br>3. The total number of callbacks is consistent with the number of requests sent. | PASS |
| SegarTestCase022 | Topic IDL HelloWorld Send and Receive | 1. Create a Writer node and a Reader node, the Topic is chatter_idl, and the type is HelloWorld (IDL). <br>2. Writer constructs HelloWorld according to the serial number seq loop: set ready, various integer/floating point, string, wide string, raw_bytes, samples array, nested detail and other fields. <br>3. Reader uses seq in the callback to verify that the ready, integer, floating point, note, wide_note, raw_bytes, samples, detail.detail_id/detail.description of the received message are consistent with those sent. | 1. Reader can receive all sent messages. <br>2. The ready, integer, floating point, string, array, nested structure, etc. of each message are consistent with those sent by Writer. | PASS |
| SegarTestCase023 | Topic Proto Chatter Send and Receive | 1. Create Writer/Reader, the Topic is chatter_proto, and the type is Chatter (Proto). <br>2. Writer sets timestamp, lidar_timestamp, seq, and content before publishing; Reader verifies that timestamp>0, seq, and content are consistent with sending in the callback, and verifies lidar_timestamp ≥ timestamp. | 1. The number of messages received is the same as that sent. <br>2. timestamp, seq, and content are correct. <br>3. lidar_timestamp ≥ timestamp. | PASS |
| SegarTestCase024 | Topic IDL String sending and receiving | 1. Create Writer/Reader, the Topic is chatter_string, and the type is std_msgs/msg/String. <br>2. Writer sets data to to_string(seq) according to the serial number and publishes it. <br>3. Reader verifies that the data of the received message is consistent with the string corresponding to seq. | 1. The number of messages received is the same as that sent. <br>2. The data of each message corresponds to the sending sequence number. | PASS |
| SegarTestCase025 | Topic RawMessage (Proto) sending and receiving | 1. Create a Writer and use Proto type (such as Chatter) to publish messages to chatter_raw_proto. <br>2. Create a Reader, subscribe to the Topic using the RawMessage type, deserialize the Proto by message_type through the ProtobufFactory in the callback, and verify that each field (such as seq, content, timestamp) is consistent with the sending. <br>3. Verify that the number of received items is consistent with that of sent items. | 1. RawMessage can receive and parse Proto. <br>2. Each field of the parsed Proto is consistent with the sent one. <br>3. The number of messages received is the same as that sent. | PASS |
